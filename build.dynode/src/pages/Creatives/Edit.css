/* Edit Page Styles */
.edit-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f5f5f5;
}

.edit-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  background-color: white;
  border-bottom: 1px solid #e8e8e8;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
  z-index: 100;
}

.edit-header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.edit-header-right {
  display: flex;
  align-items: center;
}

.edit-title {
  margin: 0 !important;
  color: #333;
}

.edit-content {
  flex: 1;
  display: flex; /* allow the canvas child to stretch */
  flex-direction: column;
  overflow: auto;
  padding: 0; /* no parent padding so canvas fills available area */
  min-height: 0; /* ensure flex children can shrink properly */
}

.edit-content.preview-mode {
  padding: 0;
  background-color: white;
}

.edit-content.edit-mode {
  background-color: #f5f5f5;
  padding: 0; /* explicitly ensure no padding in edit mode */
}

/* Loading and Error States */
.edit-loading,
.edit-error {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  gap: 16px;
  padding: 24px;
  text-align: center;
}

.edit-loading p {
  margin-top: 16px;
  color: #666;
  font-size: 16px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .edit-header {
    flex-direction: column;
    gap: 12px;
    align-items: stretch;
  }

  .edit-header-left,
  .edit-header-right {
    justify-content: space-between;
  }

  .edit-content {
    padding: 16px;
  }

  .edit-title {
    font-size: 18px !important;
  }
}

@media (max-width: 480px) {
  .edit-header {
    padding: 12px 16px;
  }

  .edit-content {
    padding: 12px;
  }

  .edit-header-left {
    gap: 8px;
  }
}

/* Layer panel styles */
.panel.left-elements {
  background: #2b2b2b;
  padding: 6px 8px 6px 8px; /* tighten left gutter to align rows to the left */
  border-radius: 8px;
  color: #fff;
}
.panel.left-elements .element-list {
  margin-top: 6px;
  padding: 0; /* ensure no extra left padding inside the scroller */
}
.layer-node {
  position: relative;
  margin: 0; /* ensure no extra gap between nodes */
  /* shift entire node by depth so toggle/connector/label align consistently to the left */
  margin-left: calc(var(--depth, 0) * var(--layer-indent));
}

/* constant indentation between levels (px) */
:root {
  --layer-indent: 10px; /* 10px per level */
}

.collapse-toggle {
  /* smaller square toggle like the screenshot */
  padding: 0;
  font-size: 11px;
  background: rgba(255, 255, 255, 0.06);
  border: none;
  color: #fff;
  border-radius: 4px;
  line-height: 1;
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.layer-label {
  display: inline-block;
  text-align: left;
  flex: 1 1 auto; /* allow label to take remaining space */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 12px;
  font-weight: 400; /* regular */
}
.layer-children {
  /* remove external margin so connector lines stay continuous; spacing comes from row padding */
  margin-top: 0;
}

/* connecting vertical line on the left of nested items */
.layer-node::before {
  content: none; /* keep for compatibility if needed */
}

/* Connectors are rendered as inline SVGs now; disable pseudo-element connectors to avoid duplication */
.layer-row::before,
.layer-row::after,
.layer-node.has-children > .layer-children::before {
  display: none !important;
  content: none !important;
}

/* For nodes that have children, don't draw the parent's own depth-line (it would show behind the toggle).
   Instead draw the child-column vertical line from the center of the parent's toggle downwards using
   the node-level pseudo-element. This creates a line that appears to originate from the parent's button.
*/
.layer-node.has-children > .layer-row::before {
  display: none;
}

/* Per-row vertical segments: draw a short/long vertical piece for each child row instead of
   a full group column. This prevents long continuous columns and gives a per-item T/L look. */

/* default: hide per-row before */
.layer-row::before {
  content: "";
  position: absolute;
  /* align vertical segment under the center of the collapse toggle/placeholder */
  left: calc(16px + (var(--depth, 0) * var(--layer-indent)));
  width: 1px;
  background: rgba(255, 255, 255, 0.06);
  pointer-events: none;
  display: none;
}

/* show per-row vertical for child rows (depth > 0) — full height for intermediate children */
.layer-row[data-depth]:not([data-depth="0"])::before {
  /* short vertical segment inside the row so segments don't visually join into a long column */
  top: 6px;
  bottom: 6px;
  display: block;
}

/* last child: only draw the top half so combined with the horizontal arm it forms an L */
.layer-node.is-last > .layer-row::before,
.layer-node[data-is-last="true"] > .layer-row::before {
  /* L: vertical from near top down to center, then horizontal arm */
  top: 6px;
  bottom: 50%;
  display: block;
}

/* NOTE: do not remove node-level ::before for .is-last - that was removing the child-column
  on parents that were themselves the last child. Child-column must render even when the
  parent is last in its own list. The row-level vertical is shortened below for L-shaped.
*/

/* shorten vertical connector for nodes that are last in their list so it ends at the row center,
   forming an L when combined with the horizontal arm; targets the visible row's pseudo-element */
.layer-node.is-last .layer-row::before,
.layer-node[data-is-last="true"] .layer-row::before {
  bottom: 50%;
}

/* horizontal branch to connect toggle area to label */
.layer-row::after {
  content: "";
  position: absolute;
  /* start the arm a little right of the vertical segment so the elbow appears neat */
  left: calc(20px + (var(--depth, 0) * var(--layer-indent)));
  top: 50%;
  transform: translateY(-50%);
  width: calc(var(--layer-indent) - 8px);
  height: 1px;
  background: rgba(255, 255, 255, 0.06);
  pointer-events: none;
  display: none;
}

/* show horizontal arm for any row that is a child (depth > 0) */
.layer-row[data-depth]:not([data-depth="0"])::after {
  display: block;
}

/* show horizontal connector only for last-child so it forms an L */
.layer-node.is-last .layer-row::after,
.layer-node[data-is-last="true"] .layer-row::after {
  display: block; /* last child keeps the arm; combined with shortened vertical -> L */
}
/* no special first-child offset so connectors remain continuous */

/* if a node has no children, hide the vertical connector completely to avoid stray lines */
.layer-node.no-children .layer-row::before {
  display: none;
}

/* Horizontal arm and last-child vertical shortening handled below. */

/* For the last child, mask the lower part of the parent-column so the column visually ends at
   the last child's center, forming an L. We place a masking pseudo-element on the last child node
   that covers the column area from center downwards using the panel background. */
/* removed group masking and group column — per-row segments above provide the T/L shapes */

/* Layer row fixed height and centered content */
.layer-row {
  display: flex;
  align-items: center;
  gap: 6px; /* slightly tighter gap so controls are compact */
  height: 28px; /* slightly tighter rows so connectors touch */
  padding: 4px 6px;
  box-sizing: border-box;
  border-radius: 6px;
  position: relative; /* so the ::after horizontal branch lines up */
  z-index: 0; /* make sure row pseudo-elements sit below interactive controls */
  margin: 0;
  /* remove per-row left padding so toggle/connector sit flush with the node left edge
     (depth is applied on the parent .layer-node via margin-left) */
  padding-left: 0;
}

/* selected row background (selection shown via row background, not checkbox) */
.layer-row.selected {
  background: rgba(98, 78, 255, 0.15);
}

/* hide any leftover checkbox inputs (markup removed) */
.layer-row input[type="checkbox"] {
  display: none;
}

/* ensure the collapse toggle (button) renders above connector lines so lines don't cross the button visually */
.collapse-toggle {
  position: relative;
  z-index: 2;
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.collapse-placeholder {
  width: 16px;
  height: 16px;
  display: inline-block;
}

.connector {
  width: 8px; /* reduce reserved horizontal space so icon sits closer */
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.connector svg {
  margin-left: -6px; /* pull connector graphic left so it sits between arrow and icon */
  display: block;
}

/* Icon styling based on data-icon on the row */
.layer-row[data-icon="widget"] .layer-label::before,
.layer-row[data-icon="shape"] .layer-label::before,
.layer-row[data-icon="layout"] .layer-label::before,
.layer-row[data-icon="unknown"] .layer-label::before {
  content: "";
  display: inline-block;
  width: 14px;
  height: 14px;
  margin-right: 8px;
  vertical-align: middle;
}
.layer-row[data-icon="widget"] .layer-label::before {
  border-radius: 2px;
  border: 2px solid rgba(255, 255, 255, 0.12);
  background: transparent;
}
.layer-row[data-icon="shape"] .layer-label::before {
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.06);
  border: 2px solid rgba(255, 255, 255, 0.06);
}
.layer-row[data-icon="layout"] .layer-label::before {
  border-radius: 2px;
  border: 2px solid rgba(255, 255, 255, 0.06);
  background: rgba(255, 255, 255, 0.02);
}

/* small top-line when the arrow isn't the first element (e.g., icon appears first) */
.layer-row[data-collapsible="false"]::before {
  content: "";
  position: absolute;
  left: calc(16px + (var(--depth, 0) * var(--layer-indent)));
  top: 6px;
  width: 1px;
  height: 8px;
  background: rgba(255, 255, 255, 0.06);
}

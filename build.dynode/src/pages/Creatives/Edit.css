/* Edit Page Styles */
.editor-container {
  /* Positioning & stacking */
  position: absolute;
  inset: 0;
  transform: translateZ(0);
  -webkit-transform: translateZ(0);

  /* Layout */
  display: flex;
  flex-direction: column;
  height: 100vh;
  flex: 1;
  overflow: auto;
  padding: 0;
  min-height: 0;
  position: relative;

  /* Visual */
  background-color: #f5f5f5;
}

.editor-container.preview-mode {
  padding: 0;
  background-color: white;
}

.editor-container.edit-mode {
  background-color: #f5f5f5;
  padding: 0;
}
.edit-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f5f5f5;
}

.edit-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  background-color: white;
  border-bottom: 1px solid #e8e8e8;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
  z-index: 100;
}

.edit-header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.edit-header-right {
  display: flex;
  align-items: center;
}

.edit-title {
  margin: 0 !important;
  color: #333;
}

.edit-content {
  flex: 1;
  display: flex; /* allow the canvas child to stretch */
  flex-direction: column;
  overflow: auto;
  padding: 0; /* no parent padding so canvas fills available area */
  min-height: 0; /* ensure flex children can shrink properly */
  position: relative; /* positioning context for overlay panels */
}

/* Selector overlay sits above the canvas but below panels */
.editor-selector {
  position: absolute;
  inset: 0;
  pointer-events: none; /* contains a visual-only frame; children may enable events */
  z-index: 2500;
}

.selection-frame {
  transition: all 120ms ease;
}

/* Overlay panel container: position absolutely over the canvas so panel groups
   don't participate in document flow and can't increase page height. Panels
   inside will enable pointer-events as needed. */
.editor-panels {
  position: absolute;
  inset: 0;
  pointer-events: none; /* root overlay ignores pointer events, panels enable them */
  z-index: 4000;
}

.panel-group {
  position: absolute; /* position each group separately */
  pointer-events: auto;
  display: block;
}

.panel {
  position: relative; /* panels' internal layout is relative to group */
  pointer-events: auto; /* enable interactions inside panels */
}

.panel-group.pos-top-left {
  top: 16px;
  left: 16px;
}
.panel-group.pos-top-center {
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
}
.panel-group.pos-top-right {
  top: 16px;
  right: 16px;
}

/* width constraints for the panels inside each positioned group */
.panel-group.pos-top-left .panel {
  min-width: 280px;
  max-width: 350px;
}
.panel-group.pos-top-center .panel {
  max-width: 720px;
  width: auto;
}
.panel-group.pos-top-right .panel {
  min-width: 280px;
  max-width: 350px;
  left: auto;
}

.editor {
  position: absolute;
  inset: 0;
  display: block;
  transform: translateZ(
    0
  ); /* create stacking context for predictable z-index */
  -webkit-transform: translateZ(0);
}

.editor-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
  height: auto;
  min-height: 0;
}

.edit-content.preview-mode {
  padding: 0;
  background-color: white;
}

.edit-content.edit-mode {
  background-color: #f5f5f5;
  padding: 0; /* explicitly ensure no padding in edit mode */
}

/* Loading and Error States */
.edit-loading,
.edit-error {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  gap: 16px;
  padding: 24px;
  text-align: center;
}

.edit-loading p {
  margin-top: 16px;
  color: #666;
  font-size: 16px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .edit-header {
    flex-direction: column;
    gap: 12px;
    align-items: stretch;
  }

  .edit-header-left,
  .edit-header-right {
    justify-content: space-between;
  }

  .edit-content {
    padding: 16px;
  }

  .edit-title {
    font-size: 18px !important;
  }
}

@media (max-width: 480px) {
  .edit-header {
    padding: 12px 16px;
  }

  .edit-content {
    padding: 12px;
  }

  .edit-header-left {
    gap: 8px;
  }
}

/* Layer panel styles */
.panel {
  background: #2b2b2b;
  padding: 6px 8px 6px 8px;
  border-radius: 8px;
  color: #fff;
  box-shadow: 0 8px 28px rgba(0, 0, 0, 0.5);
}

.panel .element-list {
  margin-top: 6px;
  padding: 0; /* ensure no extra left padding inside the scroller */
}
/* Left panel specific layout sections */
.panel .top-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.panel .scene-selector {
  padding: 6px 2px;
}
.panel .scene-btn {
  background: rgba(255, 255, 255, 0.04);
  color: #fff;
  border: none;
}
.panel .scene-btn.active {
  background: rgba(98, 78, 255, 0.22);
}

/* stacked scene rows */
.panel .scene-selector {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.panel .scene-row {
  padding: 8px 10px;
  border-radius: 6px;
  cursor: pointer;
  background: transparent;
}
.panel .scene-row .scene-label {
  color: #fff;
  font-size: 13px;
}
.panel .scene-row.active {
  background: rgba(98, 78, 255, 0.12);
}

/* element row icon and actions */
.panel .layer-row {
  height: 32px;
  display: flex;
  align-items: center;
}
.panel .layer-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 15px;
  color: rgba(255, 255, 255, 0.9);
}
.panel .collapse-toggle {
  width: 10px;
  height: 20px;
  padding: 0;
  border: none;
  background: rgba(255, 255, 255, 0.04);
}
.panel .collapse-placeholder {
  display: inline-block;
  width: 10px;
  height: 16px;
}
.panel .layer-actions {
  display: flex;
  align-items: center;
  gap: 6px;
}
.panel .layer-actions .action-btn {
  border: none;
  background: transparent;
  color: #fff;
  padding: 2px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 4px;
}
.panel .layer-actions .action-btn:hover {
  background: rgba(255, 255, 255, 0.04);
}

/* visual separator between left panel sections */
.panel .left-separator {
  height: 1px;
  background: rgba(255, 255, 255, 0.04);
  margin: 8px 0;
  border-radius: 1px;
}
.layer-node {
  position: relative;
  margin: 0; /* ensure no extra gap between nodes */
  /* shift entire node by depth so toggle/connector/label align consistently to the left */
  margin-left: calc(var(--depth, 0) * var(--layer-indent));
}

/* constant indentation between levels (px) */
:root {
  --layer-indent: 15px; /* 15px per level */
}

.collapse-toggle {
  /* smaller square toggle like the screenshot */
  padding: 0;
  font-size: 11px;
  background: rgba(255, 255, 255, 0.06);
  border: none;
  color: #fff;
  border-radius: 4px;
  line-height: 1;
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.layer-label {
  display: inline-block;
  text-align: left;
  flex: 1 1 auto; /* allow label to take remaining space */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 12px;
  font-weight: 400; /* regular */
}
.layer-children {
  /* remove external margin so connector lines stay continuous; spacing comes from row padding */
  margin-top: 0;
}

/* connecting vertical line on the left of nested items */
.layer-node::before {
  content: none; /* keep for compatibility if needed */
}

/* Connectors are rendered as inline SVGs now; disable pseudo-element connectors to avoid duplication */
.layer-row::before,
.layer-row::after,
.layer-node.has-children > .layer-children::before {
  display: none !important;
  content: none !important;
}

/* For nodes that have children, don't draw the parent's own depth-line (it would show behind the toggle).
   Instead draw the child-column vertical line from the center of the parent's toggle downwards using
   the node-level pseudo-element. This creates a line that appears to originate from the parent's button.
*/
.layer-node.has-children > .layer-row::before {
  display: none;
}

/* Per-row vertical segments: draw a short/long vertical piece for each child row instead of
   a full group column. This prevents long continuous columns and gives a per-item T/L look. */

/* default: hide per-row before */
.layer-row::before {
  content: "";
  position: absolute;
  /* align vertical segment under the center of the collapse toggle/placeholder */
  left: calc(16px + (var(--depth, 0) * var(--layer-indent)));
  width: 1px;
  background: rgba(255, 255, 255, 0.06);
  pointer-events: none;
  display: none;
}

/* show per-row vertical for child rows (depth > 0) — full height for intermediate children */
.layer-row[data-depth]:not([data-depth="0"])::before {
  /* short vertical segment inside the row so segments don't visually join into a long column */
  top: 6px;
  bottom: 6px;
  display: block;
}

/* last child: only draw the top half so combined with the horizontal arm it forms an L */
.layer-node.is-last > .layer-row::before,
.layer-node[data-is-last="true"] > .layer-row::before {
  /* L: vertical from near top down to center, then horizontal arm */
  top: 6px;
  bottom: 50%;
  display: block;
}

/* NOTE: do not remove node-level ::before for .is-last - that was removing the child-column
  on parents that were themselves the last child. Child-column must render even when the
  parent is last in its own list. The row-level vertical is shortened below for L-shaped.
*/

/* shorten vertical connector for nodes that are last in their list so it ends at the row center,
   forming an L when combined with the horizontal arm; targets the visible row's pseudo-element */
.layer-node.is-last .layer-row::before,
.layer-node[data-is-last="true"] .layer-row::before {
  bottom: 50%;
}

/* horizontal branch to connect toggle area to label */
.layer-row::after {
  content: "";
  position: absolute;
  /* start the arm a little right of the vertical segment so the elbow appears neat */
  left: calc(20px + (var(--depth, 0) * var(--layer-indent)));
  top: 50%;
  transform: translateY(-50%);
  width: calc(var(--layer-indent) - 8px);
  height: 1px;
  background: rgba(255, 255, 255, 0.06);
  pointer-events: none;
  display: none;
}

/* show horizontal arm for any row that is a child (depth > 0) */
.layer-row[data-depth]:not([data-depth="0"])::after {
  display: block;
}

/* show horizontal connector only for last-child so it forms an L */
.layer-node.is-last .layer-row::after,
.layer-node[data-is-last="true"] .layer-row::after {
  display: block; /* last child keeps the arm; combined with shortened vertical -> L */
}
/* no special first-child offset so connectors remain continuous */

/* if a node has no children, hide the vertical connector completely to avoid stray lines */
.layer-node.no-children .layer-row::before {
  display: none;
}

/* Horizontal arm and last-child vertical shortening handled below. */

/* For the last child, mask the lower part of the parent-column so the column visually ends at
   the last child's center, forming an L. We place a masking pseudo-element on the last child node
   that covers the column area from center downwards using the panel background. */
/* removed group masking and group column — per-row segments above provide the T/L shapes */

/* Layer row fixed height and centered content */
.layer-row {
  display: flex;
  align-items: center;
  gap: 6px; /* slightly tighter gap so controls are compact */
  height: 28px; /* slightly tighter rows so connectors touch */
  padding: 4px 6px;
  box-sizing: border-box;
  border-radius: 6px;
  position: relative; /* so the ::after horizontal branch lines up */
  z-index: 0; /* make sure row pseudo-elements sit below interactive controls */
  margin: 0;
  /* remove per-row left padding so toggle/connector sit flush with the node left edge
     (depth is applied on the parent .layer-node via margin-left) */
  padding-left: 0;
}

/* selected row background (selection shown via row background, not checkbox) */
.layer-row.selected {
  background: rgba(98, 78, 255, 0.15);
}

/* stronger selector for left panel rows to override incidental rules */
.panel.left-elements .layer-row.selected {
  background: rgba(98, 78, 255, 0.15) !important;
  transition: background 120ms ease-in-out;
}

/* Ensure any left-panel row marked via data-selected attribute is visibly highlighted */
.panel.left-elements [data-selected="true"],
.panel.left-elements .layer-row[data-selected="true"] {
  background: rgba(98, 78, 255, 0.15) !important;
}

/* Remove connector pseudo-elements (vertical/horizontal arms) when a row is selected
   so the small connector segments don't appear as thin lines at the top/bottom of the
   selected background. */
.layer-row.selected::before,
.layer-row.selected::after,
.panel.left-elements .layer-row.selected::before,
.panel.left-elements .layer-row.selected::after,
.panel.left-elements [data-selected="true"]::before,
.panel.left-elements [data-selected="true"]::after {
  display: none !important;
  content: none !important;
}

/* Prevent selection from changing layout or shifting siblings: keep dimensions identical
   and avoid adding margins or box-shadow that would push other rows. */
.layer-row.selected,
.panel.left-elements .layer-row.selected,
.panel.left-elements [data-selected="true"] {
  height: 32px !important;
  margin: 0 !important;
  padding-top: 4px !important;
  padding-bottom: 4px !important;
  padding-left: 0 !important; /* depth margin is handled by parent .layer-node */
  box-shadow: none !important;
  transform: none !important;
  z-index: 1; /* keep selected row visually above connectors but don't change flow */
}

/* full-row clickable cursor */
.panel.left-elements .layer-row {
  cursor: pointer;
}

/* hide any leftover checkbox inputs (markup removed) */
.layer-row input[type="checkbox"] {
  display: none;
}

/* ensure the collapse toggle (button) renders above connector lines so lines don't cross the button visually */
.collapse-toggle {
  position: relative;
  z-index: 2;
  width: 16px;
  height: 16px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.collapse-placeholder {
  width: 16px;
  height: 16px;
  display: inline-block;
}

.connector {
  width: 8px; /* reduce reserved horizontal space so icon sits closer */
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.connector svg {
  margin-left: -6px; /* pull connector graphic left so it sits between arrow and icon */
  display: block;
}

/* Icon styling based on data-icon on the row */
.layer-row[data-icon="widget"] .layer-label::before,
.layer-row[data-icon="shape"] .layer-label::before,
.layer-row[data-icon="layout"] .layer-label::before,
.layer-row[data-icon="unknown"] .layer-label::before {
  content: "";
  display: inline-block;
  width: 14px;
  height: 14px;
  margin-right: 8px;
  vertical-align: middle;
}
.layer-row[data-icon="widget"] .layer-label::before {
  border-radius: 2px;
  border: 2px solid rgba(255, 255, 255, 0.12);
  background: transparent;
}
.layer-row[data-icon="shape"] .layer-label::before {
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.06);
  border: 2px solid rgba(255, 255, 255, 0.06);
}
.layer-row[data-icon="layout"] .layer-label::before {
  border-radius: 2px;
  border: 2px solid rgba(255, 255, 255, 0.06);
  background: rgba(255, 255, 255, 0.02);
}

/* small top-line when the arrow isn't the first element (e.g., icon appears first) */
.layer-row[data-collapsible="false"]::before {
  content: "";
  position: absolute;
  left: calc(16px + (var(--depth, 0) * var(--layer-indent)));
  top: 6px;
  width: 1px;
  height: 8px;
  background: rgba(255, 255, 255, 0.06);
}
